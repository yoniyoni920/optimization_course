// find_first_exiting_id.c

#include <stdio.h>
#include <stdlib.h>

#include "simplex.h"

// Assuming y = B-1D, x = B-1b
// CHANGE
//int find_exiting_id(double y[][N], double x[], int enter_id, 
//int n, int m)

int find_first_exiting_id(double y[][N], double x[], int enter_id, 
int n, int m)
// END OF CHANGE
{

  int i,j,temp_min_index, init_flag, q, unbounded_flag;
  double temp_min, temp;
 

  for(i=0; i < n; i++)
    if (d[i] == enter_id)
        q = i;
  init_flag = 0;

  unbounded_flag = 1;
  for(i=0; i < m; i++)
  {
   printf("y[%d][%d] = %lf, x[%d] = %lf %lf\n", i,q, y[i][q],i, x[i]);
   printf("init_flag = %d\n", init_flag);
   if (y[i][q] > 0.0)
   {
   unbounded_flag = 0;

    temp = x[i]/y[i][q];
    printf("i = %d, temp = %lf\n", i, temp);
    if (init_flag == 0)
    {
     temp_min = temp;
     temp_min_index = i;
     init_flag = 1;
    } // if 
    else
      if (temp < temp_min)
      {
       temp_min = temp;
       temp_min_index = i;
      } // if 
     else
      if ((temp == temp_min) && (d[i] < d[temp_min_index]))
      {
       temp_min = temp;
       temp_min_index = i;
      } // if 

 
    printf("2: i = %d\n", i);
  
   } // if

  } // for

  printf("unbounded flag = %d\n", unbounded_flag);

// CHANGE
  if( unbounded_flag == 1)
  {
   fprintf(stderr, "Unbounded linear program!\n");
   exit(0);
  } // if
// END OF CHANGE

    printf("temp_min_index  = %d, temp_min  = %lf\n", temp_min_index , 
                                     temp_min ); 
// CHANGE

//  *step_size = temp_min;  
// END OF CHANGE  
return temp_min_index;

} // find_exiting_id

// find_first_negative.c

#include "simplex.h"


int find_first_negative()
{
// Assumptions: d[i] is original index, rd orderred by i=0,.., n-1 
//                                                  d[0] ... d[n-1]

  int first_index, i, found;
  double temp_value;

  first_index = n+1;
  temp_value = rd[0];
  found = 0;
  for(i=0; i < (n - m) && (found == 0); i++)
    if ( rd[i] <  0)
     {
       if ( first_index > d[m+i])
          first_index = d[m+i];
     } // if
//   else

 printf("first_index = %d\n", first_index); 

 return first_index;
} // find_first_negative

// simplex.h


#include <stdio.h>

// Global Variables


#define N 128
#define M 64


extern  double  A[N][N];
extern  double B[N][N];
extern  double C[N];
extern  double D[N][N];
extern  double c[N];
extern  double b[N];
extern  double b_aux[N];
extern  double cb[N];
extern  double cbBI[N];
extern  double cbBID[M];
extern  double cd[N];
extern  double rd[N];
extern  double BID[N][N];
extern  double W[N][N];
extern  double BI[N][N];
extern  double BIA_aux[N][N];

extern double A_aux[N][N];
extern double BIb[N];

extern double epsilon;
  
extern  int d[N];
extern  int d_aux[N];
extern  int basis[N];
extern  int n;
extern  int m;
extern  FILE *fp;


extern   int Initial_n;
extern    double Initial_W[N][N];
extern   double Initial_cb[N];
extern  double Initial_cd[N];
extern  double Initial_A[N][N];
extern  double Initial_A_aux[N][N];
extern  double Initial_c[N];
extern   double Initial_c_aux[N];
extern  int Initial_basis[N];
extern  double Initial_D[N][N];
extern  int Initial_d[N];
extern   double Initial_B[N][N];
extern  double Initial_BIb[N];

extern   double Initial_C[N][N];
extern   double Initial_b[N];
extern   double Initial_b_aux[N];
extern   double Initial_rd[N];
extern   double Initial_BID[N][N];
extern   double Initial_BI[N][N];
extern   double Initial_cbBI[N];
extern   double Initial_cbBID[N];
extern   double Initial_BIA_aux[N][N];





// Global functions

extern void copy_matrix(double Dest[][N], double Source[][N], int n, 
int m);

extern void copy_vector(double Dest[], double Source[], int n);

extern void bublesort(int array[],  int n);

extern void print_result();


extern void Initial_simplex_algorithm();

extern void simplex_algorithm();


// CHANGE

//extern int find_exiting_id(double y[][N], double x[], int enter_id,
//int n, int m);

extern int find_exiting_id(double y[][N], double x[], int enter_id, 
int n, int m);
extern int find_first_exiting_id(double y[][N], double x[], int enter_id, 
int n, int m);
// END OF CHANGE


extern int find_most_negative();

extern int find_Initial_most_negative();

extern void inv_gaussian(double B[][N], double A[][N],  
   int n);

extern  void matrix_mult(double C[][N], double A[][N], double B[][N],  
int 
n, 
int m, int p);

extern void matrix_vector_mult(double c[], 
double A[][N], double b[], int n, int m); 

extern void vector_matrix_mult(double c[], double b[], double A[][N],   
  int n, int m);

extern void print_no_solution();

extern void print_original_system();

extern void print_result();

extern void read_file();

extern void swap_colums(double A[][N], int i, int j, int m, int n);

extern void swap_rows(double W[][N], int n, int m1, int m2);


extern void vector_subtract(double result_v[], double v1[], double v2[],  
int n);


extern void 
copy_submatrix(double Dest[][N], double Source[][N],  int istart,
   int depth, int jstart, int length);


extern void copy_initial_matrix();

extern double find_min_value(double rd[], int n);


extern void compute_cb_cd();

extern void compute_Initial_cb_Initial_cd();
 
extern void print_initial_solution(); 

extern void print_solution();

extern void Initial_swap_colums(int i, int j);

extern void stage2_swap_colums(int i, int j);

extern void Initial_set_d();
extern void set_d();

extern void set_Initial_A_aux();
extern void set_A_aux();

extern void bublesort_d(int array[], double darr[],  int n);

extern void erase_epsilons_matrix(double darray[][N], int m, int n);
extern void erase_epsilons_vector(double darray[], int n);

extern int find_Initial_exiting_id(double y[][N], double x[], int 
enter_id, int n, int m);

extern void copy_to_initial_matrix();

extern int find_first_negative();



// simplex_algorithm.c

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "simplex.h"

void simplex_algorithm()
{
   int i, j,k, optimal_flag, enter_id,  exiting_id, itemp, basis_i;
   double dtemp, min_value;
// CHANGE
//   double step_size;
// END OF CHANGE
   int count=1;

  optimal_flag = 0;

  printf(" m = %d, n = %d\n", m, n);

  printf("\nbasis1:\n");
  for(i=0; i < m; i++)
    printf(" %d ", basis[i]);
  printf("\n");


  printf("A:\n");
  for(i=0; i < m; i++)
   {
     for(j=0; j < n; j++)
       printf(" %6.2lf ", A[i][j]);
     printf("\n");
   } // for


  
 while(optimal_flag == 0)
 {

  printf("count = %d\n", count);
  count++;
 
  bublesort(basis, m);

  printf("\nbasis2:\n");
  for(i=0; i < m; i++)
    printf(" %d ", basis[i]);
  printf("\n");

 
  set_d();


   printf("\nd:\n");
   for(i=0; i < n; i++)
     printf(" %d ", d[i]);
   printf("\n");


   set_A_aux();

  printf("\nA_aux (B, D):\n");
  for(i=0; i < m; i++)
   {
     for(j=0; j < n; j++)
       printf(" %6.2lf ", A_aux[i][j]);
     printf("\n");
   } // for


   copy_submatrix(B, A_aux, 0, m, 0, m); // Set B

  printf("\nB:\n");
  for(i=0; i < m; i++)
   {
     for(j=0; j < m; j++)
        printf(" %6.2lf ", B[i][j]);
     printf("\n");
   } // for  


   inv_gaussian(BI, B,  m); // BI = B-1  

   erase_epsilons_matrix(BI, m, m);

   printf("\nBI:\n");
   for(i=0; i < m; i++)
    {
      for(j=0; j < m; j++)
         printf(" %6.2lf ", BI[i][j]);
      printf("\n");
    } // for  


   matrix_mult(BIA_aux, BI, A_aux,
            m, m, n);
   erase_epsilons_matrix(BIA_aux, m, n);
   
  printf("\nBIA_aux (I, B-1*D):\n");
  for(i=0; i < m; i++)
   {
     for(j=0; j < n; j++)
        printf(" %6.2lf ", BIA_aux[i][j]);
     printf("\n");
   } // for  

  printf("\nA_aux (B,D):\n");
  for(i=0; i < m; i++)
   {
     for(j=0; j < n; j++)
        printf(" %6.2lf ", A_aux[i][j]);
     printf("\n");
   } // for  


   printf("b:\n");
   for(i=0; i < m; i++)
     printf(" %6.2lf ", b[i]);



   matrix_vector_mult(BIb, BI, b, m, m);
   erase_epsilons_vector(BIb, m);

   printf("\nBIb:\n");
   for(i=0; i < m; i++)
     printf(" %6.2lf ", BIb[i]);
   printf("\n");


   copy_submatrix(D, A_aux,  
         0, m, m, n-m); // Set D

  printf("D:\n");
  for(i=0; i < m; i++)
   {
     for(j=0; j < n-m; j++)
        printf(" %6.2lf ", D[i][j]);
     printf("\n");
   } // for  

// END OF FOR DEBUG ONLY

   compute_cb_cd();

   printf("\ncb:\n");
   for(i=0; i < m; i++)
     printf(" %6.2lf ", cb[i]);
   printf("\n");

   printf("\ncd:\n");
   for(i=0; i < (n-m); i++)
     printf(" %6.2lf ", cd[i]);
   printf("\n");


// cbBI = cb * B-1

   vector_matrix_mult(cbBI, cb, BI, m, m); 
   erase_epsilons_vector(cbBI, m);

   printf("\ncbBI:\n");
   for(i=0; i < m; i++)
     printf(" %6.2lf ", cbBI[i]);
   printf("\n");


    vector_matrix_mult(cbBID, cbBI, D, 
    m, n - m); 
   erase_epsilons_vector(cbBID, n - m);


  printf("\ncbBID:\n");
  for(i=0; i < (n - m); i++)
        printf(" %6.2lf ", cbBID[i]);
   printf("\n");



    vector_subtract(rd, cd,  cbBID, 
     n-m);
    erase_epsilons_vector(rd, n - m);

   printf("\nrd( cd - cbBID ):\n");
   for(i=0; i < (n-m); i++)
     printf(" %6.2lf ", rd[i]);
   printf("\n\n");



    min_value = find_min_value(rd, n-m);
    if (min_value >= 0.0) 
       optimal_flag = 1;
    else
    {
// CHANGE
//        enter_id = find_most_negative();
//
        enter_id = find_first_negative();
        exiting_id = 
//      find_exiting_id(BIA_aux,BIb,
//           enter_id, n, m);
      find_first_exiting_id(BIA_aux,BIb,
           enter_id, n, m);
//     if(step_size == 0.0)
//       optimal_flag = 1;
     printf("\nenter_id  = %d,  exiting_id = %d," 
              " d[exiting_id] = %d\n", 
                                  enter_id, exiting_id, 
                                  d[exiting_id]);

  printf("pivot: enter_id = %d, exiting_id = %d\n", enter_id,
d[exiting_id]);


   

   basis[exiting_id] =   enter_id;
   printf("\nbasis3:\n");
   for(i=0; i < m; i++)
     printf(" %d ", basis[i]);
   printf("\n");

    } // else 

 } // while

} //simplex_algorithm
         